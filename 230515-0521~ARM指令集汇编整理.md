# ARM指令集整理

[toc]

# ARM处理器工作模式

| 工作模式            | 解释                                 |
| ------------------- | ------------------------------------ |
| User                | 非特权模式，大部分任务执行在这种模式 |
| System（特权）      | 和User共用寄存器的特权模式           |
| FIQ（特权）         | 快速中断模式                         |
| IRQ（特权）         | 低速中断模式                         |
| Supervisor          | 复位或者软中断的工作模式             |
| Abort（特权）       | 预取异常的工作模式                   |
| Undef（特权）       | 未定义指令的工作模式                 |
| Moniter（Cortex-A） | 执行安全监控代码的模式               |



## ARM汇编指令格式

```assembly
<Mnemonic>{<cond>}{s} {Rd},{Rn},{shifter_operand}
```

| 原文            | 解释                                     |
| --------------- | ---------------------------------------- |
| Mnemonic        | 助记符                                   |
| cond            | 条件码                                   |
| s               | 当前指令执行会引起CPSR寄存器的NZCV位变化 |
| Rd              | 目标寄存器                               |
| Rn              | 第一操作寄存器                           |
| shifter_operand | 第二操作数                               |

注：比较指令没有目标寄存器，不加s修饰也会引起CPSR寄存器NZCV位变化。

## ARM指令集助记符

| 种类           | 指令  | 含义                                                         |
| -------------- | ----- | ------------------------------------------------------------ |
| 数据传输指令   | MOV   | MOV Rd,Rn；将第一操作寄存器的数据移到目标指令集Rd            |
|                | MVN   | MVN Rd,Rn；将第一操作寄存器的数据取反后移到目标指令集Rd      |
| 比较指令       | CMP   | CMP Rd,Rn；减法比较Rd-Rn，更新CPSR                           |
|                | CMN   | CMN Rd,Rn；加法比较Rd+Rn，更新CPSR                           |
|                | TST   | TST Rd,Rn；位测试Rd&Rn，更新CPSR                             |
|                | TEQ   | TEQ Rd,Rn；相等测试Rd^Rn,更新CPSR                            |
| 加法指令       | ADD   | ADD Rd,Rn,shifted_opt；Rd=Rn+shifted_opt                     |
|                | ADC   | ADC Rd,Rn,shifted_opt；Rd=Rn+Rn+C(CPSR)；加法进位指令        |
| 减法指令       | SUB   | SUB Rd,Rn,shifted_opt；Rd=Rn-shifted_opt                     |
|                | SBC   | SUB Rd,Rn,shifted_opt；Rd=Rn-shifted_opt-C(CPSR)；减法借位指令 |
|                | RSB   | RSB Rd,Rn,shifted_opt；Rd=shifted_opt-Rn；反减               |
|                | RSC   | RSB,Rd,Rn,shifted_opt;Rd=shifted_opt-Rn-C(CPSR)；反减借位    |
| 位运算指令     | AND   | AND Rd,Rn,shifted_opt；Rd=Rn&shifted_opt                     |
|                | ORR   | ORR Rd,Rn,shifted_opt；Rd=Rn\|shifted_opt                    |
|                | EOR   | EOR Rd,Rn,shifted_opt；Rd=Rn^shifted_opt；相同为零不同为一   |
|                | BIC   | EOR Rd,Rn,shifted_opt；取二进制shifter_opt为1的位将Rn对应的位写零，结果导入到Rd |
| 无符号乘法指令 | UMULL | UMULL Rd_low，Rd_high，Rn，Rm；Rd_high:Rd_low=Rn*Rm          |
|                | UMLAL | UMLAL Rd_low，Rd_high，Rn，Rm；Rd_high:Rd_low=Rn*Rm+Rd_high:Rd_low |

## 条件码(conditional execution)

| 条件码 | 助记符 | 寄存器标识位条件 | 含义               |
| ------ | ------ | ---------------- | ------------------ |
| 0000   | EQ     | Z=1              | 相等               |
| 0001   | NE     | Z=0              | 不相等             |
| 0010   | CS     | C=1              | 无符号数大于或等于 |
| 0011   | CC     | C=0              | 无符号数小于       |
| 0100   | MI     | N=1              | 负数               |
| 0101   | PL     | N=0              | 正数或零           |
| 0110   | VS     | V=1              | 溢出               |
| 0111   | VC     | V=0              | 未溢出             |
| 1000   | HI     | C=1&&Z=1         | 无符号数大于       |
| 1001   | LS     | C=0\|\|Z=1       | 无符号数小于或等于 |
| 1010   | GE     | N=V              | 带符号数大于或等于 |
| 1011   | LT     | N!=V             | 带符号数小于       |
| 1100   | GT     | Z=0&&N=V         | 带符号数大于       |
| 1101   | LE     | Z=1\|\|N!=V      | 带符号数小于或等于 |
| 1110   | AL     | Any              | Always             |

跳转指令B配合条件码，可实现条件跳转的逻辑结构。

## 示例代码

### MOV/MVN赋值指令

```assembly
@transmit commmand
MOV R0,#1
MVN R0,#1
```

MOV将值赋给目标寄存器，MVN取反输入（因为是无符号数，所以0x-1回环为0xFFFFFFFF）。

### CMP/CMN/TST/TEQ比较指令

```assembly
MOV R0,#5
MOV R1,#3
CMP R0,R1      @ CPSR
SUBHI R0,R0,R1 @ R0<-(R0-R1)
SUBLS R1,R1,R0 
```

CMP比较后CPSR寄存器的C位由0置为1。

```assembly
@compare command
MOV R0,#2
CMP R0,#2
CMP R0,#3

MOV R0,#2
CMN R0,#-2

MOV R0,#16
TST R0,#(1<<4)

MOV R0,#234
TEQ R0,#234
```

### ADD加法运算/ADC进位加法运算

```assembly
MOV R0,#0x1
MOV R1,#0xFFFFFFFF
MOV R2,#0x1
MOV R3,#0x1
ADDS R5,R3,R1
ADC R4,R0,R2   @进位
NOP
NOP
```

| 寄存器 | 运行前     | 第一步后   | 第二步后   | 第三步后   | 第四步后   | 第五步后   | 第六步后   |
| ------ | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| R0     | 0x00000000 | 0x00000001 |            |            |            |            |            |
| R1     |            | 0x00000000 | 0xFFFFFFFF |            |            |            |            |
| R2     |            |            | 0x00000000 | 0x00000001 |            |            |            |
| R3     |            |            |            | 0x00000000 | 0x00000001 |            |            |
| R4     |            |            |            |            | 0x00000000 | 0x00000003 |            |
| R5     |            |            |            |            |            | 0x00000000 | 0x00000000 |

| 指令                  | CPSR                             |
| :-------------------- | -------------------------------- |
| CMP减法比较           | 小于（N置1），大于等于（C,Z置1） |
| CMN加法比较（与负数） |                                  |
| TST位比较（与位移量） | C置1                             |
| TEQ相等测试           |                                  |

### SUB减法运算/SBC借位减法运算

```assembly
MOV R0,#0x2
MOV R1,#0x1
MOV R2,#0x1
MOV R3,#0xFFFFFFFF
SUB R5,R1,R3
SBC R4,R0,R2  @借位
NOP
NOP
```

R0&R1组成数1的高八位和低八位，R2&R3组成数二的高八位低八位。

R1-R3时借位，此时R0被借位后为0x00000001。

| 寄存器 | 运行前     | 第一步后   | 第二步后   | 第三步后   | 第四步后   | 第五步后   | 第六步后   |
| ------ | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| R0     | 0x00000000 | 0x00000002 |            |            |            |            |            |
| R1     |            | 0x00000000 | 0x00000001 |            |            |            |            |
| R2     |            |            | 0x00000000 | 0x00000001 |            |            |            |
| R3     |            |            |            | 0x00000000 | 0xFFFFFFFF |            |            |
| R4     |            |            |            |            | 0x00000000 | 0x00000000 |            |
| R5     |            |            |            |            |            | 0x00000000 | 0x00000002 |

### RSB反减运算

因为受汇编格式第一第二操作数皆为寄存器而不能是常数的限制，所以出现常数为被减数，寄存器值为减数的情况时需要使用RSB指令。

```assembly
MOV R1,#0x01
RSB R0,R1,#0xFF @反减
```

寄存器变化：

| 寄存器 | 运行前     | 运行后     |
| ------ | ---------- | ---------- |
| R0     | 0x00000000 | 0x000000FE |
| R1     | 0x00000000 | 0x00000001 |

### BIC按位清零/MSR寄存器给特殊寄存器赋值

```assembly
MRS R0,CPSR
BIC R0,#0x3 @按位清零
MSR CPSR,R0
NOP
NOP
```

寄存器变化：

| 寄存器   | 运行前     | 第一步后   | 第二步后   | 第三步     |
| -------- | ---------- | ---------- | ---------- | ---------- |
| R0       | 0x00000000 | 0x000000D3 | 0x000000D0 | 0x000000D0 |
| CPSR     | 0x000000D3 | 0x000000D3 | 0x000000D3 | 0x000000D0 |
| 模式状态 | SVS        | SVS        | SVS        | USER       |

### UMULL乘法运算/UMLAL乘法累加运算

```assembly
MOV r2,#2
MOV R3,#0XFFFFFFFF
UMULL R0,R1,R2,R3
UMLAL R0,R1,R2,R3
NOP
NOP
```

寄存器变化

| 寄存器 | 运行前     | 第一步后   | 第二步后   | 第三步后   | 第四步后   |
| ------ | ---------- | ---------- | ---------- | ---------- | ---------- |
| R2     | 0x00000000 | 0x00000002 |            |            |            |
| R3     |            | 0x00000000 | 0xFFFFFFFF |            |            |
| R1     |            |            | 0x00000000 | 0x00000001 | 0x00000003 |
| R0     |            |            | 0x00000000 | 0xFFFFFFFE | 0xFFFFFFFC |

R1为高32位，R0位低32位。

UMULL：0xFFFFFFFF\*2=0x1FFFFFFFE ;

UMLAL:Rd_high:Rd_low=Rn\*Rm+Rd_high:Rd_low ;2\*0xFFFFFFFF+0x1FFFFFFFE=0x3FFFFFFFC

### B 跳转指令

```assembly
	MOV R0,#0X1
	MOV R1,#0X2
	B MDADD
LOOP:
	B .
MDADD:
	ADD R2,R0,R1;
	MOV PC,LR
```

B MDADD可以使程序跳过LOOP部分，直接执行MDADD部分。MOV PC,LR使程序PC指针又指向程序起始位置。
