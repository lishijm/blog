# SDIO协议梳理附SD卡读写以及FATFS移植实例
SDIO为一种与SD-Card，SD-MMC或者SD总线设备通信的协议，基于命令和数据流。

## 物理层

| 协议项         | 协议内容                                                     |
| -------------- | ------------------------------------------------------------ |
| 通信模式       | 全双工                                                       |
| 连接线电气特性 | 6线通信：CLK（时钟线）,CMD（命令线）,DAT0~3（双向数据线）    |
|                | 3线供电：vdd（电源线），vss1（地线1），vss2（地线2）         |
| 电平值         | 默认模式，高速模式：3.3v                                     |
|                | SDR12,SDR25，SDR50，SDR104，DDR50,UHS156：1.8v               |
| 速度           | 默认模式，最高频率：25MHz，最高速度：12.5MB/s                |
|                | 高速模式：最高频率50MHz，最高速度：25MB/s                    |
| 主从模式       | 默认速度：一主多从的同步星形拓扑结构，高速模式：一主一从的同步点对点结构 |

SD卡在初始化时，处理命令会单独发送到每个卡，允许应用程序检测卡以及分配逻辑地址给物理卡槽，数据总是单独发送（接收）到每张卡，但为了简化卡的堆栈操作，在初始化过程结束后，所有命令都是同时发送所有卡，地址信息包含在命令包中。

SD总线允许数据线的动态配置。上电后，SD默认只使用DAT0来传输数据，即1bit-wide 模式。

> 所以在笔者使用6.8及以前版本CubeMx生成初始化代码时会有以下BUG：
>
> CubeMX会自动在初始化时将总线宽度设为 4bits，即以下式：
> 
> hsd.Init.BusWide = SDIO_BUS_WIDE_4B;
>
> 但SD手册规定初始只能是是1 bit，之后再由HAL_SD_ConfigWideBusOperation改变为4 bits,即必须为：
>
> hsd.Init.BusWide = SDIO_BUS_WIDE_1B;

初始化之后，主机可以改变总线宽度，即1bit-wide模式改为4bit-wide模式，这个功能允许硬件成本和系统性能之间的简单交换。当DAT1-DAT3没有使用的时候，主机的DAT先应该被设置为输入模式。

## 数据链路层

SD总线的通信是基于命令和数据流的。由一个起始位开始，由一个停止位终止，传输由高位到低位。

* 命令（Command）：命令就是一个标记，用于发起一个操纵。有主机发送到单个卡（寻址命令）或者所有卡（广播命令）。命令在CMD线上传输。
* 响应（Response）：相应是一个标记，从所寻址的卡或者所有卡（同步）发送给主机，作为接收到命令的应答。响应在CMD线上传输。
* 数据（DATA）：数据可以从主机到卡也可以从卡到主机。数据在DAT线上传输。

无响应操作与无数据操作：

块读取操作：

块写入操作：

### 命令帧格式：

| 项名称     | 位数  | 项内容                   |
| ---------- | ----- | ------------------------ |
| 起始位     | 1bit  | 常为‘0’                  |
| 传输来源位 | 1bit  | ‘1’=host command         |
| 内容位     | 38bit | 用于传输命令或命令参数   |
| CRC校验位  | 7bit  | 用于检查内容部分传输正确 |
| 停止位     | 1bit  | 常为‘1’                  |

命令帧一帧总长度为48bit。

### 响应帧格式

响应帧有四种格式：

| 响应方式 | 格式                                                    |
| -------- | ------------------------------------------------------- |
| 1        | 方向位[1bit]+命令[8bit]+状态信息[32bit]+CRC[7bit]=48bit |
| 2        | 方向位+命令+CID/CSD寄存器+CRC=136bit                    |
| 3        | 方向位+命令+OCR寄存器+CRC=48bit                         |
| 4        | 方向位+命令+RCA寄存器+CRC=48bit                         |

### 数据包格式

#### 常规8bit数据包

| 项名称         | 位数  | 项内容   |
| -------------- | ----- | -------- |
| 起始位         | 1bit  | ‘0’      |
| 数据位第一字节 | 8bit  | 数据内容 |
| 数据位第二字节 | 8bit  | 数据内容 |
| ***            | ***   | ***      |
| 数据位第n字节  | 8bit  | 数据内容 |
| CRC            |       | 校验     |
| 停止位         | 1bibt | ’1‘      |

#### 宽位数据包（巨帧数据包）

不按字节，传输512bit数据：

| 项名称 | 位数     | 项内容       |
| ------ | -------- | ------------ |
| 起始位 | 1bit     | 0            |
| 数据位 | 512bit？ | 不按字节传输 |
| CRC    |          | 校验         |
| 停止位 | 1bit     | 1            |

## 核心代码

### 无FATFS读写512字节数据

```c
#define SD_TIMEOUT             ((uint32_t)100000000)      /* 超时时间 */
#define SD_TRANSFER_OK         ((uint8_t)0x00)
#define SD_TRANSFER_BUSY       ((uint8_t)0x01) 
#define SD_TOTAL_SIZE_BYTE(__Handle__)  (((uint64_t)((__Handle__)->SdCard.LogBlockNbr)*((__Handle__)->SdCard.LogBlockSize))>>0)
#define SD_TOTAL_SIZE_KB(__Handle__)    (((uint64_t)((__Handle__)->SdCard.LogBlockNbr)*((__Handle__)->SdCard.LogBlockSize))>>10)
#define SD_TOTAL_SIZE_MB(__Handle__)    (((uint64_t)((__Handle__)->SdCard.LogBlockNbr)*((__Handle__)->SdCard.LogBlockSize))>>20)
#define SD_TOTAL_SIZE_GB(__Handle__)    (((uint64_t)((__Handle__)->SdCard.LogBlockNbr)*((__Handle__)>SdCard.LogBlockSize))>>30)

uint8_t sdcard_read(uint8_t *pbuf,uint32_t saddr,uint32_t cnt){
    uint8_t sta=HAL_OK;
    uint32_t timeout=SD_TIMEOUT;
    uint32_t lesector=saddr;
    __disable_irq();
    sta=HAL_SD_ReadBlocks(&hsd,(uint8_t *)pbuf,lesector,cnt,SD_TIMEOUT);

    while (((HAL_SD_GetCardState(&hsd)==HAL_SD_CARD_TRANSFER)?SD_TRANSFER_OK:SD_TRANSFER_BUSY)!=SD_TRANSFER_OK){
        if(timeout--==0){
            sta=SD_TRANSFER_BUSY;
        }
    }
    __enable_irq();
    return sta;
}

uint8_t sdcard_write(uint8_t *pbuf,uint32_t saddr,uint32_t cnt){
    uint8_t sta=HAL_OK;
    uint32_t timeout=SD_TIMEOUT;
    uint32_t lesector=saddr;
    __disable_irq();
    sta=HAL_SD_WriteBlocks(&hsd,(uint8_t *)pbuf,lesector,cnt,SD_TIMEOUT);
    while (((HAL_SD_GetCardState(&hsd)==HAL_SD_CARD_TRANSFER)?SD_TRANSFER_OK:SD_TRANSFER_BUSY)!=SD_TRANSFER_OK){
        if(timeout--==0){
            sta=SD_TRANSFER_BUSY;
        }
    }
    __enable_irq();
    return sta;
}

void sd_write_test(uint32_t secaddr,uint32_t seccnt){
    uint16_t i;
    uint8_t *buf;
    uint8_t sta=0;
    uint8_t bufarr[512];
    for(i=0;i<512;i++){
        bufarr[i]=i;
    }
    buf=bufarr;
    sta=sdcard_write(buf,secaddr,seccnt);
    if(sta==0){
        printf("WRITE\r\n");
        printf("SECTOR %d DATA:\r\n", secaddr);
        for (i = 0; i <512; i++){
            printf("%x ", buf[i]);
        }
        printf("\r\nDATA ENDED\r\n");
    }
    else{
        printf("err:%d\r\n", sta);
    }
    return ;
}

void sd_read_test(uint32_t secaddr,uint32_t seccnt){
    uint16_t i;
    uint8_t *buf;
    uint8_t sta=0;
    uint8_t bufarr[512];
    buf=bufarr;
    sta=sdcard_read(buf,secaddr,seccnt);
    if(sta==0){
        printf("READ\r\n");
        printf("SECTOR %d DATA:\r\n", secaddr);
        for (i = 0; i <512; i++){
            printf("%x ", buf[i]);  /* 打印secaddr开始的扇区数据 */
        }
        printf("\r\nDATA ENDED\r\n");
    }
    else{
        printf("err:%d\r\n", sta);
    }
}
```

